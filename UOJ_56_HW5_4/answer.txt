P1. BC
A错 函数模板不能部分特化，应当被理解为重载overload
B对 类模板可以部分特化
C对 比如说template<class T>T f(T)在调用f(1)的时候自动推断T=int
D错 模板多态在编译期实现

P2. B
A错 end()不指向任何数据，其指向末尾数据后面一位
B对 erase的位置在b后方，b不失效
C错 erase的位置在c前方，c失效
D错 erase返回值是被删除元素后面一个元素的迭代器

P3. BC
A错 list底层是链表，插入删除不会导致迭代器失效
B对 key值作为索引，不能重复
C对 set内部会按照值排序
D错 vector的insert依靠迭代器实现，较慢

P4. AB
A对 operator+需要传值，加的越多后期需要传值的字符串越长，与总个数平方相当
B对 自己用用就知道了
C错 遇见空白字符就终止，包括tab和空格
D错 string也可以下标访问字符

P5. B
A错 endl不是对象
B对 ostream对象不允许复制
C错 istream和ostream是iostream的基类
D错 clear用来清空的是状态位

P6. CD
A错 ?表示{0,1}，显然符合题意
B错 正则表达式分块为(-?)(\d*)(\.(\d*))?，从左至右取()(1)(.())就能匹配1.
C对 从左到右取()(0)(SYY)(xkk)(1)就能匹配0SYYxkk1
D对 这就是用来匹配日期的，显然正确

P7. BC

P8. AD
A对 第一次调用f的时候使用复制构造，引用计数为2；函数体内构造一个t2，然后离开函数体形式参数销毁，引用计数还是2；
    之后再调用，构造形式参数，引用计数为3，但是不构造静态对象；离开函数体之后形式参数销毁，引用计数为2
B错 参见A选项解答
C错 x的生命周期是main函数，在(1)处还没有销毁
D对 

P9. A
A对 shared_ptr就是帮你自动管理指针的
B错 unique_ptr不计数
C错 weak_ptr也可以复制构造
D错 weak_ptr需要依靠shared_ptr存在，不然构造出来引用计数全为0就直接销毁